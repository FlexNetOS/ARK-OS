{
  "meta": {
    "name": "NOA-CECCA Johnson Bundle",
    "version": "3.0.0",
    "principles": "kernel-first | message-passing | async-first | zero-bloat | no-globals",
    "notes": [
      "Runs in Node >=18 or modern browser (fs writes stubbed).",
      "Autofix SBOM sets env defaults and ensures directory structure.",
      "Modules use event bus; no shared mutable state."
    ]
  },
  "sbom": {
    "env_expected": ["NOA_MODELS_DIR","NOA_DATA_DIR","NOA_PORT"],
    "env_defaults": {"NOA_MODELS_DIR":"./models","NOA_DATA_DIR":"./data","NOA_PORT":"8088"},
    "dirs_expected": ["models/","data/","data/capsules/","data/versions/","data/patches/","uploads/","vendor/wheels/"],
    "native_optional": ["tesseract","llama.cpp"]
  },
  "boot": { "entry": "core/loader", "start": "kernel/boot" },
  "modules": {
    "core/loader": "(ctx=>{const reg=new Map(),inst=new Map();function def(n,f){reg.set(n,f)}async function use(n){if(inst.has(n))return inst.get(n);const f=reg.get(n);if(!f)throw Error('module '+n+' missing');const m=await f(create(n));inst.set(n,m);return m;}function create(scope){return{scope,bus:ctx.bus,log:(...a)=>ctx.log(scope,...a),cfg:ctx.cfg,shims:ctx.shims,kv:ctx.kv,def,use}}return{def,use,create}})",
    "core/shims": "(ctx=>{const hasNode=typeof process!=='undefined'&&process.versions&&process.versions.node;const env=Object.assign({},ctx.envDefaults,hasNode?process.env:{});const memfs=(()=>{const files=new Map();const norm=p=>(p||'').replace(/\\\\/g,'/');return{readFile:async p=>{const v=files.get(norm(p));return new TextDecoder().decode(v||new Uint8Array())},writeFile:async(p,d)=>{files.set(norm(p),new TextEncoder().encode(String(d)))},exists:async p=>files.has(norm(p)),unlink:async p=>{files.delete(norm(p))},list:async pre=>{pre=norm(pre||'');return[...files.keys()].filter(k=>k.startsWith(pre))},mkdir:async p=>{files.set(norm(p)+'/.keep',new Uint8Array())}}})();let fs,path,cp,http;try{fs=require('fs/promises')}catch(_){fs=memfs}try{path=require('path')}catch(_){path={join:(...a)=>a.join('/').replace(/\\\\/g,'/'),dirname:p=>p.replace(/\\/[^/]*$/,''),basename:p=>p.split('/').pop()}}try{cp=require('child_process')}catch(_){cp={exec:(c,o,cb)=>cb(null,{stdout:'',stderr:''})}}try{http=require('http')}catch(_){http=null}return{env,fs,path,cp,http,hasNode}})",
    "core/kv": "(ctx=>{const m=new Map();return{get:async k=>m.get(k),set:async(k,v)=>{m.set(k,v)},del:async k=>m.delete(k),list:async pre=>[...m.keys()].filter(k=>k.startsWith(pre||''))}})",
    "core/bus": "(ctx=>{const subs=new Map();function on(t,fn){const a=subs.get(t)||[];a.push(fn);subs.set(t,a);return()=>{const i=a.indexOf(fn);if(i>=0)a.splice(i,1)}}async function emit(msg){const a=subs.get(msg.type)||[];const out=[];for(const fn of a)out.push(await fn(msg));return out}return{on,emit}})",
    "core/fs": "(ctx=>{const {fs,path}=ctx.shims;const safe=p=>{if(!p||p.includes('..'))throw Error('unsafe path');return p};return{ls:async dir=>{dir=safe(dir||'.');const items=await fs.list?await fs.list(dir):[];return items.map(i=>i.replace(/^\\.\\/?/,'')).filter(n=>n);},read:async p=>{p=safe(p);const buf=await fs.readFile(p);return String(buf);},write:async(p,content)=>{p=safe(p);await fs.writeFile(p,content||'');return{ok:true}},rm:async p=>{p=safe(p);await fs.unlink(p);return{ok:true}},mkdir:async d=>{d=safe(d);await fs.mkdir(d);return{ok:true}}}})",
    "core/ocr": "(ctx=>{const {cp}=ctx.shims;async function hasTesseract(){return new Promise(res=>cp.exec('tesseract -v',{timeout:1000},err=>res(!err))) }async function ocr(buf){const ok=await hasTesseract();if(!ok)return{ok:false,error:'tesseract missing'};return new Promise((resolve)=>{const tmp='ocr_input_'+Date.now()+'.png';require('fs').writeFileSync(tmp,buf,'binary');cp.exec(`tesseract ${tmp} stdout`,(err,out)=>{require('fs').unlinkSync(tmp);if(err)resolve({ok:false,error:String(err)});else resolve({ok:true,text:out.trim()})});});}return{hasTesseract,ocr}})",
    "kernel/sbom": "(async ctx=>{const {env,fs,path}=ctx.shims;async function autofix(){for(const k of ctx.cfg.sbom.env_expected){if(!env[k])env[k]=ctx.cfg.sbom.env_defaults[k]}for(const d of ctx.cfg.sbom.dirs_expected){try{await fs.mkdir(d)}catch(_){}}}async function report(){return{env,dirs:await fs.list?await fs.list('data/'):[]}}return{autofix,report}})",
    "kernel/boot": "(async ctx=>{const L=await ctx.use('core/loader');ctx.def=L.def;const sb=await ctx.use('kernel/sbom');await sb.autofix();const k=await ctx.use('kernel/kernel');await k.init();return{start:()=>k.start()}})",
    "kernel/kernel": "(async ctx=>{const bus=await ctx.use('core/bus');const agents=new Map();async function reg(name,agent){agents.set(name,agent);}async function init(){await reg('diag/logger',await ctx.use('agents/logger'));await reg('digest/ingest',await ctx.use('agents/digest'));await reg('update/apply',await ctx.use('agents/updater'));await reg('update/selftest',await ctx.use('agents/selftest'));await reg('re/selfheal',await ctx.use('agents/selfheal'));await reg('planner/kernel',await ctx.use('agents/planner'));await reg('models/manager',await ctx.use('agents/models'));await reg('graph/code',await ctx.use('agents/codegraph'));await reg('file/core',await ctx.use('agents/file'));await reg('re/reverse',await ctx.use('agents/reverse'));await reg('autopilot/core',await ctx.use('agents/autopilot'));await reg('http/server',await ctx.use('agents/http'));}async function start(){await bus.emit({type:'kernel/ready',data:{}});}bus.on('agent/register',async({data})=>{await reg(data.name,data.agent);});return{init,start,reg,agents}})",
    "agents/logger": "(async ctx=>{const bus=await ctx.use('core/bus');bus.on('log',({data})=>{ctx.log('log',data.level||'info',data.msg)});return{name:'logger'}})",
    "agents/planner": "(async ctx=>{const bus=await ctx.use('core/bus');bus.on('plan/request',async({data})=>{const goal=data.goal||'improve';return{goal,steps:[{do:'digest.scan'},{do:'models.ensure'},{do:'update.propose'},{do:'update.apply'}]}});return{name:'planner'}})",
    "agents/digest": "(async ctx=>{const {fs}=ctx.shims;const bus=await ctx.use('core/bus');const langs={json:'json',py:'python',rs:'rust',js:'js',md:'md'};const det=n=>langs[(n.split('.').pop()||'').toLowerCase()]||'text';async function parse(name,text){const lang=det(name);if(lang==='json'){try{return{lang,text:JSON.stringify(JSON.parse(text),null,2)}}catch(_){} }return{lang,text};}bus.on('digest/ingest',async({data})=>{const items=[];for(const f of data.files||[]){const body=typeof f.body==='string'?f.body:'';items.push({name:f.name,...await parse(f.name,body)});}return{ok:true,items}});bus.on('digest/file',async({data})=>{const p=data.path;if(!p)return{ok:false};const body=(await fs.readFile(p))||'';return{ok:true,file:p,...await parse(p,String(body))}});return{name:'digest',det,parse}})",
    "agents/codegraph": "(async ctx=>{const bus=await ctx.use('core/bus');function edges(lang,txt){const out=[];const lines=txt.split(/\\r?\\n/);if(lang==='python'){lines.forEach((ln,i)=>{let m=/^\\s*from\\s+([\\w\\.]+)/.exec(ln);if(m)out.push({kind:'from',target:m[1],line:i+1});m=/^\\s*import\\s+([\\w\\.]+)/.exec(ln);if(m)out.push({kind:'import',target:m[1],line:i+1});});}if(lang==='rust'){lines.forEach((ln,i)=>{let m=/^\\s*use\\s+([\\w:]+)/.exec(ln);if(m)out.push({kind:'use',target:m[1],line:i+1});m=/^\\s*mod\\s+([\\w_]+)/.exec(ln);if(m)out.push({kind:'mod',target:m[1],line:i+1});});}if(lang==='js'){lines.forEach((ln,i)=>{let m=/^\\s*import\\s+.*?from\\s+['\\\"]([^'\\\"]+)/.exec(ln);if(m)out.push({kind:'import',target:m[1],line:i+1});m=/^\\s*const\\s+.*?=\\s*require\\(['\\\"]([^'\\\"]+)/.exec(ln);if(m)out.push({kind:'require',target:m[1],line:i+1});});}return out;}bus.on('codegraph/build',async({data})=>({ok:true,edges:edges(data.lang||'js',data.text||'')}));return{name:'codegraph',edges}})",
    "agents/updater": "(async ctx=>{const {fs}=ctx.shims;const bus=await ctx.use('core/bus');async function preflight(changes){return{ok:true,diffs:(changes||[]).map(c=>({file:c.file,preview:String(c.content||'').slice(0,400)}))};}async function apply(changes){const diffs=[];for(const ch of changes||[]){const p=ch.file;const old=(await fs.exists(p)?String(await fs.readFile(p)):'');const next=String(ch.content||'');diffs.push({file:p,before:old.slice(0,4000),after:next.slice(0,4000)});await fs.writeFile(p,next);}return{ok:true,diffs};}bus.on('update/preflight',async({data})=>preflight(data.changes));bus.on('update/apply',async({data})=>apply(data.changes));return{name:'updater',preflight,apply}})",
    "agents/selftest": "(async ctx=>{const bus=await ctx.use('core/bus');async function run(){try{for(const [n,code] of Object.entries(ctx.cfg.modules||{})){new Function(code);}}catch(e){return{ok:false,error:String(e)};}return{ok:true};}bus.on('selftest/run',async()=>run());return{name:'selftest',run}})",
    "agents/selfheal": "(async ctx=>{const bus=await ctx.use('core/bus');const errs=[];bus.on('error/report',({data})=>{errs.push({ts:Date.now(),data});});bus.on('error/last',()=>({last:errs.at(-1)||null}));return{name:'selfheal'}})",
    "agents/models": "(async ctx=>{const bus=await ctx.use('core/bus');const slots=new Map();async function activate(slot,name){slots.set(slot.toLowerCase(),{name,engine:name.endsWith('.gguf')?'llama.cpp':'vllm'});return{ok:true,slot:slot.toLowerCase(),name};}bus.on('models/activate',async({data})=>activate(data.slot||'smalllm',data.name));bus.on('models/slots',async()=>({slots:[...slots.entries()].map(([s,v])=>({slot:s,...v}))}));bus.on('models/generate',async({data})=>{const s=slots.get((data.slot||'smalllm').toLowerCase());if(!s)return{ok:false,error:'slot empty'};const text=(data.prompt||'').slice(0,96)+' ...[stub]';return{ok:true,text};});return{name:'models',activate}})",
    "agents/autopilot": "(async ctx=>{const bus=await ctx.use('core/bus');let auto=true,interval=4000,restartFn=null,loop=null,goal='refactor & improve';function setRestart(fn){restartFn=fn;}async function tick(){await bus.emit({type:'log',data:{level:'info',msg:'autopilot cycle'}});const plan=await bus.emit({type:'plan/request',data:{goal}});/* plan ignored in stub */;/* simulate patch */;const changes=[];if(changes.length){await bus.emit({type:'update/preflight',data:{changes}});await bus.emit({type:'update/apply',data:{changes}});const test=await bus.emit({type:'selftest/run',data:{}});const ok=test.pop()||{};if(ok.ok&&auto&&restartFn){await restartFn();}}}function start(){if(loop)return;loop=setInterval(()=>tick().catch(e=>bus.emit({type:'error/report',data:String(e)})),interval);}function stop(){if(loop){clearInterval(loop);loop=null;}}bus.on('ap/start',async()=>{start();return{ok:true}});bus.on('ap/stop',async()=>{stop();return{ok:true}});bus.on('ap/opts',async({data})=>{if(typeof data.auto_restart==='boolean')auto=data.auto_restart;if(data.interval)interval=Math.max(1000,Number(data.interval));if(loop){stop();start();}return{ok:true,auto,interval}});bus.on('ap/set_goal',async({data})=>{goal=data.goal||goal;return{ok:true,goal}});bus.on('ap/status',async()=>({running:!!loop,auto,interval,goal}));return{name:'autopilot',start,stop,setRestart}})",
    "agents/file": "(async ctx=>{const bus=await ctx.use('core/bus');const fs=await ctx.use('core/fs');bus.on('fs/ls',async({data})=>{return{ok:true,items:await fs.ls(data.path||'.')}});bus.on('fs/read',async({data})=>{return{ok:true,content:await fs.read(data.path)}});bus.on('fs/write',async({data})=>{await fs.write(data.path,data.content);return{ok:true}});bus.on('fs/rm',async({data})=>{await fs.rm(data.path);return{ok:true}});bus.on('fs/mkdir',async({data})=>{await fs.mkdir(data.path);return{ok:true}});return{name:'file'}})",
    "agents/reverse": "(async ctx=>{const bus=await ctx.use('core/bus');const digest=await ctx.use('agents/digest');const {fs}=ctx.shims;async function scan(dir){const items=await fs.list(dir);const out=[];for(const name of items){const p=dir+'/'+name;const exists=await fs.exists(p);if(!exists)continue;const body=String(await fs.readFile(p)||'');const {lang}=await digest.parse(p,body);const size=body.length;const sha=require?require('crypto').createHash('sha256').update(body).digest('hex').slice(0,12):'';out.push({name,p,lang,size,sha});}return{ok:true,files:out};}async function clone(src,dst){const items=await fs.list(src);for(const name of items){const p=src+'/'+name;const body=String(await fs.readFile(p)||'');await fs.write(dst+'/'+name,'// cloned\\n'+body);}return{ok:true}}bus.on('re/scan',async({data})=>scan(data.path||'.'));bus.on('re/clone',async({data})=>clone(data.src,data.dst));return{name:'reverse',scan,clone}})",
    "agents/selfheal": "(async ctx=>{const bus=await ctx.use('core/bus');const errs=[];bus.on('error/report',({data})=>{errs.push({ts:Date.now(),data});});bus.on('error/last',()=>({last:errs.at(-1)||null}));bus.on('error/clear',()=>{errs.length=0;return{ok:true}});return{name:'selfheal'}})",
    "agents/selftest": "(async ctx=>{const bus=await ctx.use('core/bus');async function run(){try{for(const code of Object.values(ctx.cfg.modules||{})){new Function(code);}return{ok:true}}catch(e){return{ok:false,error:String(e)}}}bus.on('selftest/run',async()=>run());return{name:'selftest',run}})",
    "agents/http": "(async ctx=>{const {http,env}=ctx.shims;const bus=await ctx.use('core/bus');if(!http)return{name:'http(stub)'};const port=Number(env.NOA_PORT||8088);function send(res,code,obj){res.writeHead(code,{'content-type':'application/json'});res.end(JSON.stringify(obj));}function body(req){return new Promise(resolve=>{let d='';req.on('data',c=>d+=c);req.on('end',()=>{try{resolve(JSON.parse(d||'{}'));}catch(_){resolve({})});});});}const server=http.createServer(async(req,res)=>{try{const u=req.url||'';if(req.method==='GET'&&u==='/api/stats'){return send(res,200,{ok:true})}if(req.method==='POST'&&u==='/api/models/activate'){const d=await body(req);const r=await bus.emit({type:'models/activate',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/ap/start'){const r=await bus.emit({type:'ap/start',data:{}});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/ap/stop'){const r=await bus.emit({type:'ap/stop',data:{}});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/ap/opts'){const d=await body(req);const r=await bus.emit({type:'ap/opts',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/fs/ls'){const d=await body(req);const r=await bus.emit({type:'fs/ls',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/fs/read'){const d=await body(req);const r=await bus.emit({type:'fs/read',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/fs/write'){const d=await body(req);const r=await bus.emit({type:'fs/write',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/update/preflight'){const d=await body(req);const r=await bus.emit({type:'update/preflight',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/update/apply'){const d=await body(req);const r=await bus.emit({type:'update/apply',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/re/scan'){const d=await body(req);const r=await bus.emit({type:'re/scan',data:d});return send(res,200,r.pop()||{ok:false})}if(req.method==='POST'&&u==='/api/re/clone'){const d=await body(req);const r=await bus.emit({type:'re/clone',data:d});return send(res,200,r.pop()||{ok:false})}return send(res,404,{ok:false,error:'not found'});}catch(e){send(res,500,{ok:false,error:String(e)})}});server.listen(port);ctx.log('http','listening',port);return{name:'http',port}})"
  },
  "wiring": {
    "kernel": "kernel/boot",
    "agents": [
      "agents/logger",
      "agents/digest",
      "agents/codegraph",
      "agents/updater",
      "agents/selfheal",
      "agents/selftest",
      "agents/planner",
      "agents/models",
      "agents/file",
      "agents/reverse",
      "agents/autopilot",
      "agents/http"
    ]
  },
  "cfg": {
    "sbom": {
      "env_expected": ["NOA_MODELS_DIR","NOA_DATA_DIR","NOA_PORT"],
      "env_defaults": {"NOA_MODELS_DIR":"./models","NOA_DATA_DIR":"./data","NOA_PORT":"8088"},
      "dirs_expected": ["models/","data/","data/capsules/","data/versions/","data/patches/","uploads/","vendor/wheels/"]
    },
    "modules": {}
  },
  "loader": "(async function NOA_Johnson_Loader(bundle){const log=(s,...a)=>console.log('[NOA:'+s+']',...a);const envDefaults=bundle.sbom?.env_defaults||{};const api={log,cfg:bundle.cfg||{},bus:null,shims:null,kv:null,envDefaults};function compile(n,c){return new Function('ctx','return ('+c+');')(api);}const factories={};for(const[name,code] of Object.entries(bundle.modules))factories[name]=compile(name,code);const loader=await factories['core/loader'](api);api.kv=await factories['core/kv'](Object.assign(loader.create('core/kv'),api));api.shims=await factories['core/shims'](Object.assign(loader.create('core/shims'),{envDefaults}));api.bus=await factories['core/bus'](loader.create('core/bus'));const mk=n=>Object.assign(loader.create(n),{cfg:bundle.cfg||{},log,kv:api.kv,shims:api.shims,bus:api.bus});for(const name of Object.keys(bundle.modules)){if(['core/loader','core/kv','core/shims','core/bus'].includes(name))continue;loader.def(name,async()=>factories[name](mk(name)));}const boot=await factories[bundle.boot.entry](mk(bundle.boot.entry));const k=await factories[bundle.boot.start](mk(bundle.boot.start));if(k&&k.start)await k.start();return{api,boot:k}})"
}
