{
  "schema": "ark-os/agentic-bundle@0.1",
  "bundle": "ark-ai-noa-unified",
  "version": "0.1.1",
  "description": "CECCA Capsule-first agentic OS bundle with foresight engine, extended SBOM, storage adapters (PG & MinIO), local model catalog/loader, CRM proxy (shadow/write-through), network guard, Redis-backed bus option. Kernel-first, message-passing, async-only, no-globals, zero-bloat.",
  "airgapDefault": true,
  "envDefaults": {
    "AIRGAP_MODE": "true",
    "EGRESS_ALLOWLIST": "localhost,127.0.0.1",
    "CAPSULE_FS": "mem",
    "REGISTRY_HOST": "registry.local",
    "MINIO_ENDPOINT": "http://minio:9000",
    "MINIO_ACCESS_KEY": "minioadmin",
    "MINIO_SECRET_KEY": "minioadmin",
    "MINIO_BUCKET": "artifacts",
    "POSTGRES_HOST": "postgres",
    "POSTGRES_DB": "arkos",
    "POSTGRES_USER": "arkos",
    "POSTGRES_PASSWORD": "arkos",
    "PG_CONN": "postgres://arkos:arkos@postgres:5432/arkos",
    "VECTOR_BACKEND": "pgvector",
    "MODEL_POLICY": "local_only",
    "BUS": "runtime",
    "CRM_MODE": "shadow",
    "LOG_LEVEL": "info"
  },
  "wiring": {
    "topics": [
      "sys/boot",
      "sys/sbom/report",
      "sys/sbom/extended",
      "sys/policy/update",
      "capsule/spawn",
      "capsule/io",
      "digest/request",
      "digest/result",
      "models/select",
      "models/registerLocal",
      "models/loadLocal",
      "models/local/list",
      "models/registered",
      "board/plan",
      "board/risk",
      "noa/goal",
      "noa/plan",
      "noa/act",
      "noa/postmortem",
      "foresight/evaluate",
      "foresight/result",
      "storage/pg/query",
      "storage/pg/exec",
      "storage/minio/put",
      "storage/minio/get",
      "crm/proxy/request",
      "crm/proxy/response",
      "net/guard/check",
      "bus/redis/send",
      "bus/redis/recv"
    ],
    "routes": [
      { "topic": "sys/boot", "consumers": ["sbom.scanner", "sbom.extended", "security.policy", "capsule.manager", "storage.adapters.pg", "storage.adapters.minio", "net.guard", "board.directors", "agent.modelselector", "models.local", "agent.digest", "agent.microstack", "foresight.engine", "crm.proxy", "agent.noa", "ui.dynamic"] },
      { "topic": "models/select", "consumers": ["agent.modelselector"] },
      { "topic": "digest/request", "consumers": ["agent.digest"] },
      { "topic": "board/plan", "consumers": ["board.directors"] },
      { "topic": "foresight/evaluate", "consumers": ["foresight.engine"] },
      { "topic": "storage/pg/query", "consumers": ["storage.adapters.pg"] },
      { "topic": "storage/pg/exec", "consumers": ["storage.adapters.pg"] },
      { "topic": "storage/minio/put", "consumers": ["storage.adapters.minio"] },
      { "topic": "storage/minio/get", "consumers": ["storage.adapters.minio"] },
      { "topic": "models/registerLocal", "consumers": ["models.local"] },
      { "topic": "models/loadLocal", "consumers": ["models.local"] },
      { "topic": "crm/proxy/request", "consumers": ["crm.proxy"] },
      { "topic": "net/guard/check", "consumers": ["net.guard"] },
      { "topic": "noa/goal", "consumers": ["agent.noa"] }
    ]
  },
  "boot": {
    "order": [
      "shim.polyfills",
      "bus.runtime",        // may be replaced by bus.redis based on env.BUS
      "bus.redis",
      "security.policy",
      "storage.layer",
      "storage.vhdx",
      "storage.adapters.pg",
      "storage.adapters.minio",
      "net.guard",
      "capsule.manager",
      "sbom.scanner",
      "sbom.extended",
      "board.directors",
      "agent.modelselector",
      "models.local",
      "agent.digest",
      "foresight.engine",
      "crm.proxy",
      "agent.microstack",
      "agent.noa",
      "ui.dynamic"
    ],
    "entryTopic": "sys/boot"
  },
  "sbom": {
    "requiredEnv": [
      "AIRGAP_MODE",
      "MODEL_POLICY",
      "BUS",
      "CRM_MODE",
      "PG_CONN",
      "MINIO_ENDPOINT",
      "MINIO_ACCESS_KEY",
      "MINIO_SECRET_KEY",
      "MINIO_BUCKET"
    ],
    "requiredModules": [
      "bus.runtime",
      "bus.redis",
      "capsule.manager",
      "storage.layer",
      "sbom.scanner",
      "sbom.extended",
      "security.policy",
      "agent.noa",
      "foresight.engine",
      "storage.adapters.pg",
      "storage.adapters.minio",
      "models.local",
      "crm.proxy",
      "net.guard"
    ],
    "autoFix": true,
    "onBootReportTopic": "sys/sbom/report"
  },
  "modules": {
    "shim.polyfills": {
      "lang": "js",
      "code_lines": [
        "export default function createShims(){",
        "  const now = () => Date.now();",
        "  const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));",
        "  const uuid = ()=> 'u'+Math.random().toString(16).slice(2)+Date.now().toString(16);",
        "  const encodeBase64 = (s)=> typeof btoa==='function'? btoa(s): Buffer.from(s,'utf8').toString('base64');",
        "  const decodeBase64 = (s)=> typeof atob==='function'? atob(s): Buffer.from(s,'base64').toString('utf8');",
        "  const stableHash = (obj)=> {",
        "    const s = JSON.stringify(obj, Object.keys(obj).sort());",
        "    let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=(h*16777619)>>>0; }",
        "    return ('00000000'+h.toString(16)).slice(-8);",
        "  };",
        "  const log = (level, ...args)=> {",
        "    const ts = new Date().toISOString();",
        "    if (typeof console !== 'undefined') console[level] ? console[level](ts, ...args) : console.log(ts, level, ...args);",
        "  };",
        "  const safeFetch = async (url, opts={})=>{",
        "    throw new Error('safeFetch unavailable in air-gapped capsules');",
        "  };",
        "  return { now, sleep, uuid, encodeBase64, decodeBase64, stableHash, log, safeFetch };",
        "}"
      ]
    },
    "bus.runtime": {
      "lang": "js",
      "code_lines": [
        "export default function createBus({shims}){",
        "  const { uuid } = shims;",
        "  const subs = new Map();",
        "  const pending = new Map();",
        "  const on = (topic, handler)=>{",
        "    const set = subs.get(topic) || new Set(); set.add(handler); subs.set(topic,set);",
        "    return ()=> set.delete(handler);",
        "  };",
        "  const publish = async (topic, msg={})=>{",
        "    const handlers = subs.get(topic);",
        "    if(!handlers || handlers.size===0) return;",
        "    await Promise.all([...handlers].map(h=> Promise.resolve().then(()=>h({topic, ...msg}))));",
        "  };",
        "  const request = async (topic, payload={}, {timeoutMs=10000}={})=>{",
        "    const correlationId = uuid();",
        "    const p = new Promise((resolve,reject)=>{",
        "      const to = setTimeout(()=>{ pending.delete(correlationId); reject(new Error('bus timeout '+topic)); }, timeoutMs);",
        "      pending.set(correlationId,{resolve,reject,timeout:to});",
        "    });",
        "    await publish(topic, {payload, correlationId});",
        "    return p;",
        "  };",
        "  const reply = ({correlationId, ok=true, data, error})=>{",
        "    if(!correlationId) return;",
        "    const entry = pending.get(correlationId);",
        "    if(!entry) return;",
        "    clearTimeout(entry.timeout); pending.delete(correlationId);",
        "    ok ? entry.resolve(data) : entry.reject(error || new Error('unknown error'));",
        "  };",
        "  return { on, publish, request, reply };",
        "}"
      ]
    },
    "bus.redis": {
      "lang": "js",
      "code_lines": [
        "export default function createBusRedis({shims}){",
        "  // Simple stub replicating bus.runtime but labelled 'redis'; no external dependency.",
        "  const { uuid } = shims;",
        "  const subs = new Map();",
        "  const on = (topic, handler)=>{",
        "    const set = subs.get(topic) || new Set(); set.add(handler); subs.set(topic,set);",
        "    return ()=> set.delete(handler);",
        "  };",
        "  const publish = async (topic, msg={})=>{",
        "    const handlers = subs.get(topic);",
        "    if(!handlers) return;",
        "    await Promise.all([...handlers].map(h=> Promise.resolve().then(()=>h({topic, ...msg}))));",
        "  };",
        "  const pending = new Map();",
        "  const request = async (topic, payload={}, {timeoutMs=10000}={})=>{",
        "    const correlationId = uuid();",
        "    const p = new Promise((resolve,reject)=>{",
        "      const to = setTimeout(()=>{ pending.delete(correlationId); reject(new Error('bus redis timeout '+topic)); }, timeoutMs);",
        "      pending.set(correlationId,{resolve,reject,timeout:to});",
        "    });",
        "    await publish(topic, {payload, correlationId});",
        "    return p;",
        "  };",
        "  const reply = ({correlationId, ok=true, data, error})=>{",
        "    if(!correlationId) return;",
        "    const entry = pending.get(correlationId);",
        "    if(!entry) return;",
        "    clearTimeout(entry.timeout); pending.delete(correlationId);",
        "    ok ? entry.resolve(data) : entry.reject(error || new Error('unknown error'));",
        "  };",
        "  return { on, publish, request, reply };",
        "}"
      ]
    },
    "security.policy": {
      "lang": "js",
      "code_lines": [
        "export default function createPolicy({shims, env}){",
        "  let airgap = (env.AIRGAP_MODE||'true')==='true';",
        "  const allowlist = new Set((env.EGRESS_ALLOWLIST||'localhost').split(',').map(s=>s.trim()));",
        "  const setAirgap = (on)=>{ airgap=!!on; return airgap; };",
        "  const addEgress = (host)=>{ allowlist.add(host); return [...allowlist]; };",
        "  const delEgress = (host)=>{ allowlist.delete(host); return [...allowlist]; };",
        "  const canEgress = (host)=> !airgap && allowlist.has(host);",
        "  const getState = ()=> ({ airgap, allowlist:[...allowlist] });",
        "  return { setAirgap, addEgress, delEgress, canEgress, getState };",
        "}"
      ]
    },
    "storage.layer": {
      "lang": "js",
      "code_lines": [
        "export default function createStorage({shims}){",
        "  const { stableHash } = shims;",
        "  const kv = new Map();",
        "  const obj = new Map();",
        "  const putKV = async (k,v)=>{ kv.set(k, v); return true; };",
        "  const getKV = async (k)=> kv.get(k);",
        "  const delKV = async (k)=> kv.delete(k);",
        "  const putObject = async (path, data)=>{ obj.set(path, data); return { path, etag: stableHash({path,len:(data?.length||0)}) }; };",
        "  const getObject = async (path)=> obj.get(path);",
        "  const listObjects = async (prefix='')=> [...obj.keys()].filter(k=>k.startsWith(prefix));",
        "  return { putKV, getKV, delKV, putObject, getObject, listObjects };",
        "}"
      ]
    },
    "storage.vhdx": {
      "lang": "js",
      "code_lines": [
        "export default function createVHDX({shims}){",
        "  const { uuid } = shims;",
        "  const bases = new Map();",
        "  const diffs = new Map();",
        "  const createBase = (name, files={})=>{",
        "    const id = uuid(); bases.set(id,{ name, readonly:true, files:new Map(Object.entries(files))});",
        "    return { id, name };",
        "  };",
        "  const createDiff = (parentId)=>{",
        "    if(!bases.has(parentId) && !diffs.has(parentId)) throw new Error('parent VHDX not found');",
        "    const id = uuid(); diffs.set(id,{ parentId, files:new Map()}); return { id, parentId };",
        "  };",
        "  const readFile = (vhdId, path)=>{",
        "    const read = (id)=>{",
        "      if(diffs.has(id)){",
        "        const d = diffs.get(id);",
        "        if(d.files.has(path)) return d.files.get(path);",
        "        return read(d.parentId);",
        "      }",
        "      const b = bases.get(id);",
        "      return b ? b.files.get(path) : undefined;",
        "    };",
        "    return read(vhdId);",
        "  };",
        "  const writeFile = (vhdId, path, data)=>{",
        "    const d = diffs.get(vhdId);",
        "    if(!d) throw new Error('write requires differencing VHDX');",
        "    d.files.set(path, data);",
        "    return true;",
        "  };",
        "  const mountNested = (outerId, innerId, mountPoint)=>{",
        "    const d = diffs.get(outerId);",
        "    if(!d) throw new Error('mount requires differencing VHDX');",
        "    d.files.set(mountPoint+'/.vhdxref', innerId);",
        "    return true;",
        "  };",
        "  return { createBase, createDiff, readFile, writeFile, mountNested };",
        "}"
      ]
    },
    "storage.adapters.pg": {
      "lang": "js",
      "code_lines": [
        "export default function createPgAdapter({bus, storage, env, shims}){",
        "  // Stub PG adapter using storage.layer kv; tables as maps keyed by tableName",
        "  const tables = new Map();",
        "  const ensureTable = (name)=>{ if(!tables.has(name)) tables.set(name,[]); return tables.get(name); };",
        "  const exec = async ({table, values})=>{",
        "    const rows = ensureTable(table);",
        "    rows.push(values);",
        "    return { ok:true, inserted: 1 };",
        "  };",
        "  const query = async ({table, filter})=>{",
        "    const rows = ensureTable(table);",
        "    if(!filter) return rows;",
        "    return rows.filter(r=>{",
        "      for(const [k,v] of Object.entries(filter)){ if(r[k]!==v) return false; } return true;",
        "    });",
        "  };",
        "  const start = ()=>{",
        "    bus.on('storage/pg/exec', async ({payload, correlationId})=>{",
        "      try{ const res = await exec(payload||{}); bus.reply({ correlationId, ok:true, data: res }); }",
        "      catch(e){ bus.reply({ correlationId, ok:false, error: e }); }",
        "    });",
        "    bus.on('storage/pg/query', async ({payload, correlationId})=>{",
        "      try{ const res = await query(payload||{}); bus.reply({ correlationId, ok:true, data: res }); }",
        "      catch(e){ bus.reply({ correlationId, ok:false, error: e }); }",
        "    });",
        "  };",
        "  return { start, exec, query };",
        "}"
      ]
    },
    "storage.adapters.minio": {
      "lang": "js",
      "code_lines": [
        "export default function createMinioAdapter({bus, storage, env, shims}){",
        "  // Adapter stub uses storage.layer as backend.",
        "  const put = async ({key, data})=>{",
        "    await storage.putObject('/minio/'+key, data);",
        "    return { ok:true, key };",
        "  };",
        "  const get = async ({key})=>{",
        "    const val = await storage.getObject('/minio/'+key);",
        "    return { key, data: val };",
        "  };",
        "  const start = ()=>{",
        "    bus.on('storage/minio/put', async ({payload, correlationId})=>{",
        "      try{ const res = await put(payload||{}); bus.reply({ correlationId, ok:true, data: res }); } catch(e){ bus.reply({ correlationId, ok:false, error: e }); }",
        "    });",
        "    bus.on('storage/minio/get', async ({payload, correlationId})=>{",
        "      try{ const res = await get(payload||{}); bus.reply({ correlationId, ok:true, data: res }); } catch(e){ bus.reply({ correlationId, ok:false, error: e }); }",
        "    });",
        "  };",
        "  return { start, put, get };",
        "}"
      ]
    },
    "net.guard": {
      "lang": "js",
      "code_lines": [
        "export default function createNetGuard({bus, security, shims}){",
        "  const check = ({host})=>{ return security.canEgress(host); };",
        "  const start = ()=>{",
        "    bus.on('net/guard/check', ({payload, correlationId})=>{",
        "      const allowed = check(payload||{});",
        "      bus.reply({ correlationId, ok:true, data:{ allowed } });",
        "    });",
        "  };",
        "  return { start, check };",
        "}"
      ]
    },
    "capsule.manager": {
      "lang": "js",
      "code_lines": [
        "export default function createCapsules({shims, vhdx, bus}){",
        "  const { uuid, sleep } = shims;",
        "  const capsules = new Map();",
        "  const spawn = async ({baseVhd, env={}, mounts=[]})=>{",
        "    const diff = vhdx.createDiff(baseVhd).id;",
        "    const id = uuid(); const inboxTopic = 'capsule/io/'+id;",
        "    capsules.set(id,{ vhdId: diff, env, inboxTopic });",
        "    await bus.publish('capsule/spawn', { capsuleId:id, env });",
        "    return { id, inboxTopic };",
        "  };",
        "  const exec = async (capsuleId, task)=>{",
        "    await bus.publish('capsule/io', { capsuleId, task });",
        "    await sleep(1);",
        "    return { capsuleId, ok:true };",
        "  };",
        "  return { spawn, exec };",
        "}"
      ]
    },
    "sbom.scanner": {
      "lang": "js",
      "code_lines": [
        "export default function createSBOM({shims, env, modules, bus}){",
        "  const { stableHash } = shims;",
        "  const checkEnv = ()=>{",
        "    const missing = []; const req = ['AIRGAP_MODE','MODEL_POLICY','BUS','CRM_MODE','PG_CONN','MINIO_ENDPOINT','MINIO_ACCESS_KEY','MINIO_SECRET_KEY','MINIO_BUCKET'];",
        "    for(const k of req){ if(!env[k]) missing.push(k); }",
        "    return { missing, defaultsApplied:{} };",
        "  };",
        "  const checkModules = ()=>{",
        "    const names = Object.keys(modules);",
        "    const required = ['bus.runtime','bus.redis','capsule.manager','storage.layer','sbom.scanner','sbom.extended','security.policy','agent.noa','foresight.engine','storage.adapters.pg','storage.adapters.minio','models.local','crm.proxy','net.guard'];",
        "    const missing = required.filter(r=> !names.includes(r));",
        "    return { missing };",
        "  };",
        "  const fix = ({envDefaults})=>{",
        "    const applied={};",
        "    for(const [k,v] of Object.entries(envDefaults||{})){",
        "      if(!env[k]){ env[k]=v; applied[k]=v; }",
        "    }",
        "    return applied;",
        "  };",
        "  const report = ()=>{",
        "    return {",
        "      id: 'sbom-'+stableHash({t:Date.now()}),",
        "      modules: Object.fromEntries(Object.keys(modules).map(n=>[n,{lang:modules[n].lang||'js', lines: (modules[n].code_lines||[]).length}])),",
        "      env: Object.keys(env).sort(),",
        "      timestamp: new Date().toISOString()",
        "    };",
        "  };",
        "  const handleBoot = async (msg)=>{",
        "    const envStatus = checkEnv();",
        "    const modStatus = checkModules();",
        "    const applied = fix({envDefaults: msg?.envDefaults});",
        "    const rep = report();",
        "    await bus.publish('sys/sbom/report', { envStatus, modStatus, applied, report: rep });",
        "  };",
        "  const start = ()=>{",
        "    bus.on('sys/boot', handleBoot);",
        "  };",
        "  return { start };",
        "}"
      ]
    },
    "sbom.extended": {
      "lang": "js",
      "code_lines": [
        "export default function createSBOMExt({shims, env, modules, bus}){",
        "  const { stableHash } = shims;",
        "  const findEnvRefs = ()=>{",
        "    const refs = new Set();",
        "    for(const mod of Object.values(modules)){",
        "      (mod.code_lines||[]).forEach(l=>{",
        "        const m = l.match(/env\\.([A-Z0-9_]+)/g);",
        "        if(m) m.forEach(x=> refs.add(x.split('.')[1]));",
        "      });",
        "    }",
        "    return [...refs];",
        "  };",
        "  const fixMissingEnv = (envRefs)=>{",
        "    const applied={};",
        "    envRefs.forEach(k=>{ if(!env[k]){ env[k]=''; applied[k]=''; } });",
        "    return applied;",
        "  };",
        "  const handleBoot = async ()=>{",
        "    const envRefs = findEnvRefs();",
        "    const applied = fixMissingEnv(envRefs);",
        "    await bus.publish('sys/sbom/extended', { envRefs, applied });",
        "  };",
        "  const start = ()=>{ bus.on('sys/boot', handleBoot); };",
        "  return { start };",
        "}"
      ]
    },
    "board.directors": {
      "lang": "js",
      "code_lines": [
        "export default function createBoard({bus, shims}){",
        "  const { uuid } = shims;",
        "  const seats = ['strategy','security','ops','finance','legal','growth','digest'];",
        "  const advise = async ({topic, payload, correlationId})=>{",
        "    if(topic==='board/plan'){",
        "      const planId = uuid();",
        "      const recs = seats.map(s=>({seat:s, note:'ok', risk: s==='security'? 'review-SBOM' : 'low'}));",
        "      bus.reply({correlationId, ok:true, data:{ planId, recs }});",
        "    }",
        "  };",
        "  const start = ()=>{ bus.on('board/plan', advise); };",
        "  return { start };",
        "}"
      ]
    },
    "agent.modelselector": {
      "lang": "js",
      "code_lines": [
        "export default function createModelSelector({bus, shims, env}){",
        "  const { uuid } = shims;",
        "  const policy = env.MODEL_POLICY || 'local_only';",
        "  const registry = new Map([",
        "    ['embed-small', {id:'embed-small', tier:'local', task:'embed', cost:1, speed:10}],",
        "    ['code-gguf', {id:'code-gguf', tier:'local', task:'code', cost:2, speed:7}],",
        "    ['reason-lite', {id:'reason-lite', tier:'local', task:'reason', cost:2, speed:6}]",
        "  ]);",
        "  const select = (need)=>{",
        "    const cands = [...registry.values()].filter(m=> m.task===need.task && (policy==='local_only'? m.tier==='local' : true));",
        "    cands.sort((a,b)=>{ let score = 0; if(need.speed) score += b.speed - a.speed; if(need.costCap) score += (a.cost - b.cost); return score; });",
        "    return cands[0] || null;",
        "  };",
        "  const start = ()=>{",
        "    bus.on('models/select', ({payload, correlationId})=>{",
        "      const choice = select(payload||{task:'reason'});",
        "      bus.reply({ correlationId, ok: !!choice, data: choice || {error:'no-model'} });",
        "    });",
        "  };",
        "  return { start, select };",
        "}"
      ]
    },
    "agent.digest": {
      "lang": "js",
      "code_lines": [
        "export default function createDigest({bus, shims, storage}){",
        "  const { stableHash } = shims;",
        "  const runDigest = async (spec)=>{",
        "    const id = 'dg-'+stableHash(spec);",
        "    const profile = { id, kind: spec.kind, tokens: (spec.content||'').split(/\\W+/).filter(Boolean).slice(0,64) };",
        "    await storage.putObject('/digests/'+id+'.json', JSON.stringify(profile));",
        "    return profile;",
        "  };",
        "  const start = ()=>{",
        "    bus.on('digest/request', async ({payload, correlationId})=>{",
        "      try{ const out = await runDigest(payload||{kind:'doc', content:''});",
        "        await bus.publish('digest/result', { profile: out });",
        "        bus.reply({ correlationId, ok:true, data: out });",
        "      }catch(e){ bus.reply({ correlationId, ok:false, error: e }); }",
        "    });",
        "  };",
        "  return { start, runDigest };",
        "}"
      ]
    },
    "foresight.engine": {
      "lang": "js",
      "code_lines": [
        "export default function createForesight({bus, shims}){",
        "  const evaluate = ({ options })=>{",
        "    // options: [{id, ev, regret, reversible}]",
        "    if(!options||options.length===0) return { best:null, ranked:[] };",
        "    const ranked = options.map(o=>{",
        "      const score = (o.ev||0) - (o.regret||0);",
        "      return {...o, score, safe: !!o.reversible};",
        "    }).sort((a,b)=> b.score - a.score);",
        "    const robust = ranked.find(r=> r.safe) || ranked[0];",
        "    return { best: robust, ranked };",
        "  };",
        "  const start = ()=>{",
        "    bus.on('foresight/evaluate', ({payload, correlationId})=>{",
        "      const { best, ranked } = evaluate(payload||{});",
        "      bus.reply({ correlationId, ok:true, data: { best, ranked } });",
        "      bus.publish('foresight/result', { best, ranked });",
        "    });",
        "  };",
        "  return { start, evaluate };",
        "}"
      ]
    },
    "models.local": {
      "lang": "js",
      "code_lines": [
        "export default function createModelsLocal({bus, shims, storage, env}){",
        "  const models = new Map();",
        "  const register = async ({id, config, weights})=>{",
        "    if(models.has(id)) return { ok:false, error:'exists' };",
        "    models.set(id,{ id, config, weights });",
        "    await storage.putObject('/models/'+id+'.json', JSON.stringify({config}));",
        "    if(weights) await storage.putObject('/models/'+id+'.bin', weights);",
        "    return { ok:true, id };",
        "  };",
        "  const load = async ({id})=>{",
        "    return models.get(id) || null;",
        "  };",
        "  const list = async ()=>{ return [...models.keys()]; };",
        "  const start = ()=>{",
        "    bus.on('models/registerLocal', async ({payload, correlationId})=>{",
        "      try{ const res = await register(payload||{}); bus.reply({ correlationId, ok: res.ok, data: res }); } catch(e){ bus.reply({ correlationId, ok:false, error:e }); }",
        "    });",
        "    bus.on('models/loadLocal', async ({payload, correlationId})=>{",
        "      try{ const m = await load(payload||{}); bus.reply({ correlationId, ok: !!m, data: m || {} }); } catch(e){ bus.reply({ correlationId, ok:false, error:e }); }",
        "    });",
        "    bus.on('models/local/list', ({correlationId})=>{ bus.reply({ correlationId, ok:true, data: [...models.keys()] }); });",
        "  };",
        "  return { start, register, load, list };",
        "}"
      ]
    },
    "crm.proxy": {
      "lang": "js",
      "code_lines": [
        "export default function createCRMProxy({bus, shims, env}){",
        "  let mode = env.CRM_MODE || 'shadow'; // 'shadow' or 'write-through'",
        "  const handle = async ({endpoint, method, payload})=>{",
        "    // In shadow mode, we log and return dummy; in write-through, we pretend to call external system.",
        "    if(mode==='shadow'){",
        "      return { status:'shadow', data:null };",
        "    } else {",
        "      // stub external call by returning success; real integration would go here",
        "      return { status:'forwarded', data:{ ok:true } };",
        "    }",
        "  };",
        "  const start = ()=>{",
        "    bus.on('crm/proxy/request', async ({payload, correlationId})=>{",
        "      try{ const res = await handle(payload||{}); bus.reply({ correlationId, ok:true, data: res }); bus.publish('crm/proxy/response', { request: payload, response: res }); } catch(e){ bus.reply({ correlationId, ok:false, error:e }); }",
        "    });",
        "  };",
        "  return { start, handle };",
        "}"
      ]
    },
    "agent.microstack": {
      "lang": "js",
      "code_lines": [
        "export default function createMicroStack({bus, shims, capsules}){",
        "  const { uuid, sleep } = shims;",
        "  const baseRegistry = { base: null };",
        "  const ensureBase = ()=>{ if(!baseRegistry.base) baseRegistry.base = 'base-vhd-placeholder'; return baseRegistry.base; };",
        "  const runTask = async (task)=>{",
        "    const base = ensureBase();",
        "    const { id } = await capsules.spawn({ baseVhd: base, env: {}, mounts: [] });",
        "    await sleep(5);",
        "    const res = await capsules.exec(id, { cmd: task.cmd||'noop' });",
        "    return { capsuleId:id, ok: res.ok };",
        "  };",
        "  const start = ()=>{",
        "    bus.on('noa/act', async ({payload})=>{",
        "      if(!payload?.tasks) return;",
        "      for(const t of payload.tasks){ await runTask(t); }",
        "    });",
        "  };",
        "  return { start };",
        "}"
      ]
    },
    "agent.noa": {
      "lang": "js",
      "code_lines": [
        "export default function createNOA({bus, shims}){",
        "  const { uuid } = shims;",
        "  const plan = async (goal)=>{",
        "    const board = await bus.request('board/plan', { goal }, { timeoutMs:8000 });",
        "    const model = await bus.request('models/select', { task:'reason', costCap:2, speed:true }, { timeoutMs:8000 });",
        "    const foresight = await bus.request('foresight/evaluate', { options:[{id:'a', ev:8, regret:4, reversible:true},{id:'b', ev:9, regret:2, reversible:false},{id:'c', ev:6, regret:6, reversible:true}] }, { timeoutMs:8000 });",
        "    const tasks = [{cmd:'analyze'},{cmd:'compose'},{cmd:'integrate'}];",
        "    return { planId: board.planId, model: model.id, tasks, foresight: foresight.best.id };",
        "  };",
        "  const start = ()=>{",
        "    bus.on('noa/goal', async ({payload})=>{",
        "      const p = await plan(payload||{name:'default'});",
        "      await bus.publish('noa/plan', { plan:p });",
        "      await bus.publish('noa/act', { tasks: p.tasks });",
        "      await bus.publish('noa/postmortem', { planId: p.planId, learnings:['stub'] });",
        "    });",
        "  };",
        "  return { start };",
        "}"
      ]
    },
    "ui.dynamic": {
      "lang": "js",
      "code_lines": [
        "export default function createUI({bus}){",
        "  const start = ()=>{",
        "    bus.on('sys/sbom/report', ({envStatus, modStatus, applied, report})=>{",
        "      if (typeof console !== 'undefined') console.log('[SBOM]', {envStatus, modStatus, applied, report});",
        "    });",
        "    bus.on('sys/sbom/extended', ({envRefs, applied})=>{",
        "      if (typeof console !== 'undefined') console.log('[SBOM-EXT]', {envRefs, applied});",
        "    });",
        "    bus.on('foresight/result', ({best, ranked})=>{",
        "      if (typeof console !== 'undefined') console.log('[Foresight]', {best, ranked});",
        "    });",
        "  };",
        "  return { start };",
        "}"
      ]
    }
  },
  "kernel": {
    "lang": "js",
    "code_lines": [
      "// CECCA Kernel — kernel-first, async bus, no globals. Dynamically picks bus implementation.",
      "export async function bootJohnson(bundle){",
      "  const env = Object.assign({}, bundle.envDefaults);",
      "  const instances = new Map();",
      "  const importModule = async (name, di)=>{",
      "    if(instances.has(name)) return instances.get(name);",
      "    const mod = bundle.modules[name];",
      "    if(!mod) throw new Error('module not found: '+name);",
      "    const src = (mod.code_lines||[]).join('\\n');",
      "    const factory = new Function('exports','require','module', ...Object.keys(di||{}), src + '\\n;return exports.default || module.exports;');",
      "    const exports = {}; const module = { exports: {} };",
      "    const create = factory(exports, ()=>{ throw new Error('require disabled'); }, module, ...(Object.values(di||{})));",
      "    instances.set(name, create);",
      "    return create;",
      "  };",
      "  // shims & bus selection:",
      "  const shims = await (await importModule('shim.polyfills'))();",
      "  let busFactory;",
      "  if(env.BUS === 'redis'){",
      "    busFactory = await importModule('bus.redis');",
      "  } else {",
      "    busFactory = await importModule('bus.runtime');",
      "  }",
      "  const bus = await busFactory({ shims });",
      "  const security = await (await importModule('security.policy'))({ shims, env });",
      "  const storage = await (await importModule('storage.layer'))({ shims });",
      "  const vhdx = await (await importModule('storage.vhdx'))({ shims });",
      "  // adapters & modules:",
      "  const pg = await (await importModule('storage.adapters.pg'))({ bus, storage, env, shims });",
      "  const minio = await (await importModule('storage.adapters.minio'))({ bus, storage, env, shims });",
      "  const netGuard = await (await importModule('net.guard'))({ bus, security, shims });",
      "  const capsules = await (await importModule('capsule.manager'))({ shims, vhdx, bus });",
      "  const sbom = await (await importModule('sbom.scanner'))({ shims, env, modules: bundle.modules, bus });",
      "  const sbomExt = await (await importModule('sbom.extended'))({ shims, env, modules: bundle.modules, bus });",
      "  const board = await (await importModule('board.directors'))({ bus, shims });",
      "  const modelsel = await (await importModule('agent.modelselector'))({ bus, shims, env });",
      "  const modelsLocal = await (await importModule('models.local'))({ bus, shims, storage, env });",
      "  const digest = await (await importModule('agent.digest'))({ bus, shims, storage });",
      "  const foresight = await (await importModule('foresight.engine'))({ bus, shims });",
      "  const crm = await (await importModule('crm.proxy'))({ bus, shims, env });",
      "  const micro = await (await importModule('agent.microstack'))({ bus, shims, capsules });",
      "  const noa = await (await importModule('agent.noa'))({ bus, shims });",
      "  const ui = await (await importModule('ui.dynamic'))({ bus });",
      "  // Start services in boot order:",
      "  sbom.start(); sbomExt.start(); board.start(); modelsel.start(); modelsLocal.start(); digest.start(); foresight.start(); crm.start(); micro.start(); noa.start(); ui.start(); pg.start(); minio.start(); netGuard.start();",
      "  // Publish boot:",
      "  await bus.publish(bundle.boot.entryTopic, { envDefaults: bundle.envDefaults });",
      "  return { env, shims, bus, security, storage, vhdx, pg, minio, netGuard, capsules };",
      "}"
    ]
  }
}
